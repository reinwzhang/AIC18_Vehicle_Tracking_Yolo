#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan 10 18:42:29 2019

@author: rwzhang
"""
# =============================================================================
# Pre-Launch Check: Make sure Detections are done and the result is saved to the designated Place
# This is dedicated to run Tracking on pre-existing detection result
# If Detection result is saved in JSON format, please launch from ../yolo_video.py --tracking 1
# =============================================================================
from time import time
import argparse
from progressbar import ProgressBar
from util import load_mot, iou, save_to_csv
import pandas as pd
import os

def track_iou(detections, sigma_l, sigma_h, sigma_iou, t_min):
    """
    Simple IOU based tracker.
    See "High-Speed Tracking-by-Detection Without Using Image Information by E. Bochinski, V. Eiselein, T. Sikora" for
    more information.
    Args:
         detections (list): list of detections per frame, usually generated by util.load_mot
         sigma_l (float): low detection threshold.
         sigma_h (float): high detection threshold.
         sigma_iou (float): IOU threshold.
         t_min (float): minimum track length in frames.

    Returns:
        list: list of tracks.
    """

    tracks_active = []
    tracks_finished = []

    pbar = ProgressBar(maxval=len(detections))
    pbar.start()
    for frame_num, detections_frame in enumerate(detections):
#    for frame_num in range(5):
#        detections_frame = detections[frame_num]
        # update the starting point to be 0 not 1
        # apply low threshold to detections
        dets = [det for det in detections_frame if det['score'] >= sigma_l]

        updated_tracks = []
        for track in tracks_active:
            if len(dets) > 0:
                # get det with highest iou
                print("current_frame ", frame_num, track['bboxes'])
                best_match = max(dets, key=lambda x: iou(track['bboxes'][-1], x['bbox']))
                if iou(track['bboxes'][-1], best_match['bbox']) >= sigma_iou:
                    track['bboxes'].append(best_match['bbox'])
                    track['max_score'] = max(track['max_score'], best_match['score'])
                    #added class info:
                    track['class'] = track['class']
                    updated_tracks.append(track)

                    # remove from best matching detection from detections
                    del dets[dets.index(best_match)]

            # if track was not updated
            if len(updated_tracks) == 0 or track is not updated_tracks[-1]:
                # finish track when the conditions are met
                if track['max_score'] >= sigma_h and len(track['bboxes']) >= t_min:
                    tracks_finished.append(track)

        # create new tracks
        new_tracks = [{'bboxes': [det['bbox']], 'max_score': det['score'], 'start_frame': frame_num, 'class': det['class']} for det in dets]
        tracks_active = updated_tracks + new_tracks
        
        pbar.update(frame_num)
    pbar.finish()

    # finish all remaining active tracks
    tracks_finished += [track for track in tracks_active
                        if track['max_score'] >= sigma_h and len(track['bboxes']) >= t_min]

    return tracks_finished

def idorder_frameorder(orig_out_path, out_path):
    '''
    orig_out_path: Tracking result from iou_tracking ordred in ID order
    out_path: Convert iou_tracking result to frame order
    '''
    temp_df = pd.read_table(orig_out_path, sep = ',', header=None, names = ['frame', 'id', 'x', 'y', 'w', 'h', 'score', 'wx', 'wy', 'wz', 'class'])
    temp_df.sort_values(by=['frame', 'id'], inplace=True)
    open(out_path, 'w').close()
    temp_df.to_csv(out_path, sep = ',', header=None, index = False)
    
def main(args):
    print('loading detections...')
    det_path = os.path.expanduser('~/') + args.detection_path
    detections = load_mot(det_path)

    print('tracking...')
    start = time()
    tracks = track_iou(detections, args.sigma_l, args.sigma_h, args.sigma_iou, args.t_min)
    end = time()
    print("Finished Tracking", tracks)
    num_frames = len(detections)
    print("finished at " + str(int(num_frames / (end - start))) + " fps!")
    
    orig_out_path = os.path.expanduser('~/') + args.output_path
    save_to_csv(orig_out_path, tracks)
    
    out_path = os.path.expanduser('~/') +  args.output_path + 'ordredfrm'
    if args.frameorder:
        #reading in all the data again for re-formatting
        idorder_frameorder(orig_out_path, out_path)
    


if __name__ == '__main__':
    print('Usaage: python det_tracking.py --detection_path "2018AICity_TeamUW/data/Track3/Loc1_1/det.txt" --output "2018AICity_TeamUW/data/Track3/Loc1_1/res.txt"')
    parser = argparse.ArgumentParser(description="IOU Tracker demo script")
    parser.add_argument('-d', '--detection_path', type=str, required=True,
                        help="full path to CSV file containing the detections")
    parser.add_argument('-o', '--output_path', type=str, required=True,
                        help="output path to store the tracking results (MOT challenge devkit compatible format)")
    parser.add_argument('-sl', '--sigma_l', type=float, default=0,
                        help="low detection threshold")
    parser.add_argument('-sh', '--sigma_h', type=float, default=0.5,
                        help="high detection threshold")
    parser.add_argument('-si', '--sigma_iou', type=float, default=0.5,
                        help="intersection-over-union threshold")
    parser.add_argument('-tm', '--t_min', type=float, default=2,
                        help="minimum track length")
    parser.add_argument('-fo', '--frameorder', type=bool, default=False,
                        help="Option to convert output to be in frame order")

    args = parser.parse_args()
    main(args)
